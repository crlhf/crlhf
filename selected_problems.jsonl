{"id": 461, "title": "Hamming Distance", "difficulty": "Easy", "content": "The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers `x` and `y`, return _the **Hamming distance** between them_.\n\n**Example 1:**\n\n**Input:** x = 1, y = 4\n**Output:** 2\n**Explanation:**\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u2191   \u2191\nThe above arrows point to positions where the corresponding bits are different.\n\n**Example 2:**\n\n**Input:** x = 3, y = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= x, y <= 231 - 1`", "code": "\n    ```python\ndef hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ", "signature": "def hammingDistance(x: int, y: int) -> int:", "solution": "xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist", "prompt": "def hammingDistance(x: int, y: int) -> int:\n\"\"\"\nThe Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers `x` and `y`, return the Hamming distance between them.\n>>> hammingDistance(1, 4) 2\n>>> hammingDistance(3, 1) 1\n\"\"\""}
{"id": 125, "title": "Valid Palindrome", "difficulty": "Easy", "content": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** s =  \"A man, a plan, a canal: Panama \"\n**Output:** true\n**Explanation:**  \"amanaplanacanalpanama \" is a palindrome.\n\n**Example 2:**\n\n**Input:** s =  \"race a car \"\n**Output:** false\n**Explanation:**  \"raceacar \" is not a palindrome.\n\n**Example 3:**\n\n**Input:** s =  \"  \"\n**Output:** true\n**Explanation:** s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n\n**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.", "code": "\n    ```python\ndef isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ", "signature": "def isPalindrome(s: str) -> bool:", "solution": "cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True", "prompt": "def isPalindrome(s: str) -> bool:\n\"\"\"\nA phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.\n\n>>> isPalindrome(\"A man, a plan, a canal: Panama\") True\n>>> isPalindrome(\"race a car\") False\n>>> isPalindrome(\"  \") True\n\"\"\""}
{"id": 1271, "title": "Hexspeak", "difficulty": "Easy", "content": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`.\n\n**Example 1:**\n\n**Input:** num =  \"257 \"\n**Output:**  \"IOI \"\n**Explanation:** 257 is 101 in hexadecimal.\n\n**Example 2:**\n\n**Input:** num =  \"3 \"\n**Output:**  \"ERROR \"\n\n**Constraints:**\n\n*   `1 <= num.length <= 12`\n*   `num` does not contain leading zeros.\n*   num represents an integer in the range `[1, 1012]`.", "code": "\n    ```python\ndef to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ", "signature": "def to_hexspeak(num: str) -> str:", "solution": "n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)", "prompt": "def to_hexspeak(num: str) -> str:\n\"\"\"\nA decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit '0' with the letter 'O', and the digit '1' with the letter 'I'. Such a representation is valid if and only if it consists only of the letters in the set {'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}.\n\nGiven a string `num` representing a decimal integer `n`, return the **Hexspeak representation** of `n` if it is valid, otherwise return \"ERROR\".\n\n>>> to_hexspeak(\"257\") \"IOI\"\n>>> to_hexspeak(\"3\") \"ERROR\"\n>>> to_hexspeak(\"16\") \"IO\"\n>>> to_hexspeak(\"170\") \"AAO\"\n>>> to_hexspeak(\"123456789\") \"75BCD15\"\n\"\"\""}
{"id": 1134, "title": "Armstrong Number", "difficulty": "Easy", "content": "Given an integer `n`, return `true` _if and only if it is an **Armstrong number**_.\n\nThe `k`\\-digit number `n` is an Armstrong number if and only if the `kth` power of each digit sums to `n`.\n\n**Example 1:**\n\n**Input:** n = 153\n**Output:** true\n**Explanation:** 153 is a 3-digit number, and 153 = 13 + 53 + 33.\n\n**Example 2:**\n\n**Input:** n = 123\n**Output:** false\n**Explanation:** 123 is a 3-digit number, and 123 != 13 + 23 + 33 = 36.\n\n**Constraints:**\n\n*   `1 <= n <= 108`", "code": "\n    ```python\ndef is_armstrong(n: int) -> bool:\n    power_sum = 0\n    original = n\n    k = len(str(n))\n    while n > 0:\n        digit = n % 10\n        power_sum += digit ** k\n        n //= 10\n    return power_sum == original\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ", "signature": "def is_armstrong(n: int) -> bool:", "solution": "power_sum = 0\n    original = n\n    k = len(str(n))\n    while n > 0:\n        digit = n % 10\n        power_sum += digit ** k\n        n //= 10\n    return power_sum == original", "prompt": "def is_armstrong(n: int) -> bool:\n\"\"\"\nGiven an integer `n`, return `true` if and only if it is an Armstrong number.\n\nThe `k`-digit number `n` is an Armstrong number if and only if the `kth` power of each digit sums to `n`.\n\n>>> is_armstrong(153) True\n>>> is_armstrong(123) False\n>>> is_armstrong(9474) True\n>>> is_armstrong(9475) False\n\"\"\""}
{"id": 1078, "title": "Occurrences After Bigram", "difficulty": "Easy", "content": "Given two strings `first` and `second`, consider occurrences in some text of the form `\"first second third \"`, where `second` comes immediately after `first`, and `third` comes immediately after `second`.\n\nReturn _an array of all the words_ `third` _for each occurrence of_ `\"first second third \"`.\n\n**Example 1:**\n\n**Input:** text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n**Output:** \\[\"girl\",\"student\"\\]\n\n**Example 2:**\n\n**Input:** text = \"we will we will rock you\", first = \"we\", second = \"will\"\n**Output:** \\[\"we\",\"rock\"\\]\n\n**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists of lowercase English letters and spaces.\n*   All the words in `text` a separated by **a single space**.\n*   `1 <= first.length, second.length <= 10`\n*   `first` and `second` consist of lowercase English letters.", "code": "\n    ```python\ndef remove_outer_parentheses(s: str) -> str:\n    result = []\n    opened = 0\n\n    for c in s:\n        if c == '(':\n            if opened > 0:\n                result.append(c)\n            opened += 1\n        elif c == ')':\n            if opened > 1:\n                result.append(c)\n            opened -= 1\n\n    return ''.join(result)\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ", "signature": "def remove_outer_parentheses(s: str) -> str:", "solution": "result = []\n    opened = 0\n\n    for c in s:\n        if c == '(':\n            if opened > 0:\n                result.append(c)\n            opened += 1\n        elif c == ')':\n            if opened > 1:\n                result.append(c)\n            opened -= 1\n\n    return ''.join(result)", "prompt": "def remove_outer_parentheses(s: str) -> str:\n\"\"\"\nGiven two strings `first` and `second`, consider occurrences in some text of the form `\"first second third \"`, where `second` comes immediately after `first`, and `third` comes immediately after `second`.\n\nReturn _an array of all the words_ `third` _for each occurrence of_ `\"first second third \"`.\n\n>>> remove_outer_parentheses(\"alice is a good girl she is a good student\", \"a\", \"good\") [\"girl\",\"student\"]\n>>> remove_outer_parentheses(\"we will we will rock you\", \"we\", \"will\") [\"we\",\"rock\"]\n\"\"\""}
{"id": 50, "title": "Pow(x, n)", "difficulty": "Medium", "content": "Implement [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculates `x` raised to the power `n` (i.e., `xn`).\n\n**Example 1:**\n\n**Input:** x = 2.00000, n = 10\n**Output:** 1024.00000\n\n**Example 2:**\n\n**Input:** x = 2.10000, n = 3\n**Output:** 9.26100\n\n**Example 3:**\n\n**Input:** x = 2.00000, n = -2\n**Output:** 0.25000\n**Explanation:** 2\\-2 = 1/22 = 1/4 = 0.25\n\n**Constraints:**\n\n*   `-100.0 < x < 100.0`\n*   `-231 <= n <= 231-1`\n*   `n` is an integer.\n*   `-104 <= xn <= 104`", "code": "\n    ```python\ndef myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ", "signature": "def myPow(x: float, n: int) -> float:", "solution": "if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result", "prompt": "def myPow(x: float, n: int) -> float:\n\"\"\"\nImplement [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculates `x` raised to the power `n` (i.e., `x^n`).\n\n>>> myPow(2.00000, 10) 1024.00000\n>>> myPow(2.10000, 3) 9.26100\n>>> myPow(2.00000, -2) 0.25000\n\"\"\""}
{"id": 255, "title": "Verify Preorder Sequence in Binary Search Tree", "difficulty": "Medium", "content": "Given an array of **unique** integers `preorder`, return `true` _if it is the correct preorder traversal sequence of a binary search tree_.\n\n**Example 1:**\n\n**Input:** preorder = \\[5,2,1,3,6\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** preorder = \\[5,2,6,1,3\\]\n**Output:** false\n\n**Constraints:**\n\n*   `1 <= preorder.length <= 104`\n*   `1 <= preorder[i] <= 104`\n*   All the elements of `preorder` are **unique**.\n\n**Follow up:** Could you do it using only constant space complexity?", "code": "\n    ```python\ndef isValidPreorder(preorder: List[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ", "signature": "def isValidPreorder(preorder: List[int]) -> bool:", "solution": "stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True", "prompt": "def isValidPreorder(preorder: List[int]) -> bool:\n\"\"\"\nGiven an array of unique integers `preorder`, return `true` if it is the correct preorder traversal sequence of a binary search tree.\n>>> isValidPreorder([5,2,1,3,6]) True\n>>> isValidPreorder([5,2,6,1,3]) False\n\"\"\""}
{"id": 625, "title": "Minimum Factorization", "difficulty": "Medium", "content": "Given a positive integer num, return _the smallest positive integer_ `x` _whose multiplication of each digit equals_ `num`. If there is no answer or the answer is not fit in **32-bit** signed integer, return `0`.\n\n**Example 1:**\n\n**Input:** num = 48\n**Output:** 68\n\n**Example 2:**\n\n**Input:** num = 15\n**Output:** 35\n\n**Constraints:**\n\n*   `1 <= num <= 231 - 1`", "code": "\n    ```python\ndef smallestFactorization(num: int) -> int:\n    if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0\n```\n    \n    The algorithm iterates from 9 to 2 (in reverse order) and divides the input number `num` by the current iterating value `i`. If `num` is completely divisible by `i`, the loop updates `result` by adding the current `i * factor` and updating the `factor` by multiplying it by 10. If `result` ever goes beyond the 32-bit signed integer limit, the function returns 0. The loop continues to iterate and divide `num` until `num` becomes 1 (i.e., all factors have been found) or there are no more appropriate dividers. If `num` is 1, i.e., all factors are found, the result is returned; otherwise, the function returns 0.\n    ", "signature": "def smallestFactorization(num: int) -> int:", "solution": "if num == 1:\n        return 1\n    result = 0\n    factor = 1\n    for i in range(9, 1, -1):\n        while num % i == 0:\n            num //= i\n            result += i * factor\n            factor *= 10\n            if result > 2**31 - 1:\n                return 0\n    return result if num == 1 else 0", "prompt": "def smallestFactorization(num: int) -> int:\n\"\"\"\nGiven a positive integer num, return the smallest positive integer x whose multiplication of each digit equals num. If there is no answer or the answer is not fit in 32-bit signed integer, return 0.\n>>> smallestFactorization(48) 68\n>>> smallestFactorization(15) 35\n>>> smallestFactorization(1) 1\n>>> smallestFactorization(100) 455\n>>> smallestFactorization(7) 7\n\"\"\""}
{"id": 48, "title": "Rotate Image", "difficulty": "Medium", "content": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[\\[7,4,1\\],\\[8,5,2\\],\\[9,6,3\\]\\]\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[5,1,9,11\\],\\[2,4,8,10\\],\\[13,3,6,7\\],\\[15,14,12,16\\]\\]\n**Output:** \\[\\[15,13,2,5\\],\\[14,3,4,1\\],\\[12,6,8,9\\],\\[16,7,10,11\\]\\]\n\n**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 20`\n*   `-1000 <= matrix[i][j] <= 1000`", "code": "\n    ```python\ndef rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n```\n    \n    The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated.\n    ", "signature": "def rotate(matrix):", "solution": null, "prompt": "def rotate(matrix):\n\"\"\"\nYou are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n>>> rotate([[1,2,3],[4,5,6],[7,8,9]]) [[7,4,1],[8,5,2],[9,6,3]]\n>>> rotate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]) [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n\"\"\""}
{"id": 1660, "title": "Correct a Binary Tree", "difficulty": "Medium", "content": "You have a binary tree with a small defect. There is **exactly one** invalid node where its right child incorrectly points to another node at the **same depth** but to the **invalid node's right**.\n\nGiven the root of the binary tree with this defect, `root`, return _the root of the binary tree after **removing** this invalid node **and every node underneath it** (minus the node it incorrectly points to)._\n\n**Custom testing:**\n\nThe test input is read as 3 lines:\n\n*   `TreeNode root`\n*   `int fromNode` (**not available to** `correctBinaryTree`)\n*   `int toNode` (**not available to** `correctBinaryTree`)\n\nAfter the binary tree rooted at `root` is parsed, the `TreeNode` with value of `fromNode` will have its right child pointer pointing to the `TreeNode` with a value of `toNode`. Then, `root` is passed to `correctBinaryTree`.\n\n**Example 1:**\n\n**Input:** root = \\[1,2,3\\], fromNode = 2, toNode = 3\n**Output:** \\[1,null,3\\]\n**Explanation:** The node with value 2 is invalid, so remove it.\n\n**Example 2:**\n\n**Input:** root = \\[8,3,1,7,null,9,4,2,null,null,null,5,6\\], fromNode = 7, toNode = 4\n**Output:** \\[8,3,1,null,null,9,4,null,null,5,6\\]\n**Explanation:** The node with value 7 is invalid, so remove it and the node underneath it, node 2.\n\n**Constraints:**\n\n*   The number of nodes in the tree is in the range `[3, 104]`.\n*   `-109 <= Node.val <= 109`\n*   All `Node.val` are **unique**.\n*   `fromNode != toNode`\n*   `fromNode` and `toNode` will exist in the tree and will be on the same depth.\n*   `toNode` is to the **right** of `fromNode`.\n*   `fromNode.right` is `null` in the initial tree from the test data.", "code": "\n    ```python\ndef thousand_separator(n: int) -> str:\n    result = str(n)\n    count = 0\n    for i in range(len(result) - 1, 0, -1):\n        count += 1\n        if count % 3 == 0:\n            result = result[:i] + '.' + result[i:]\n    return result\n```\n    \n    The algorithm first converts the given integer `n` into a string format. We'll be iterating through the string in reverse order (from last to first character) to insert dots at the thousands positions. \n\nWe keep a count initialized to 0. During the iteration, we increment the count until it's divisible by 3 (meaning we reached a thousands position). At this point, we insert the dot in the string at position `i`. The insertion process is slightly different for each programming language, but the overall idea is the same.\n\nAfter the iteration is complete, we return the modified string with dots as thousands separators. This solution works for each of the mentioned programming languages using similar logic and some language-specific syntax adjustments.\n    ", "signature": "def thousand_separator(n: int) -> str:", "solution": "result = str(n)\n    count = 0\n    for i in range(len(result) - 1, 0, -1):\n        count += 1\n        if count % 3 == 0:\n            result = result[:i] + '.' + result[i:]\n    return result", "prompt": "def thousand_separator(n: int) -> str:\n\"\"\"\nGiven an integer n, return a string representation of the number with commas as the thousand separators.\n>>> thousand_separator(987) '987'\n>>> thousand_separator(1234) '1,234'\n>>> thousand_separator(123456789) '123,456,789'\n>>> thousand_separator(0) '0'\n\"\"\""}
{"id": 2468, "title": "Split Message Based on Limit", "difficulty": "Hard", "content": "You are given a string, `message`, and a positive integer, `limit`.\n\nYou must **split** `message` into one or more **parts** based on `limit`. Each resulting part should have the suffix `\" \"`, where `\"b \"` is to be **replaced** with the total number of parts and `\"a \"` is to be **replaced** with the index of the part, starting from `1` and going up to `b`. Additionally, the length of each resulting part (including its suffix) should be **equal** to `limit`, except for the last part whose length can be **at most** `limit`.\n\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated **in order**, they should be equal to `message`. Also, the result should contain as few parts as possible.\n\nReturn _the parts_ `message` _would be split into as an array of strings_. If it is impossible to split `message` as required, return _an empty array_.\n\n**Example 1:**\n\n**Input:** message =  \"this is really a very awesome message \", limit = 9\n**Output:** \\[ \"thi<1/14> \", \"s i<2/14> \", \"s r<3/14> \", \"eal<4/14> \", \"ly <5/14> \", \"a v<6/14> \", \"ery<7/14> \", \" aw<8/14> \", \"eso<9/14> \", \"me<10/14> \", \" m<11/14> \", \"es<12/14> \", \"sa<13/14> \", \"ge<14/14> \"\\]\n**Explanation:**\nThe first 9 parts take 3 characters each from the beginning of message.\nThe next 5 parts take 2 characters each to finish splitting message. \nIn this example, each part, including the last, has length 9. \nIt can be shown it is not possible to split message into less than 14 parts.\n\n**Example 2:**\n\n**Input:** message =  \"short message \", limit = 15\n**Output:** \\[ \"short mess<1/2> \", \"age<2/2> \"\\]\n**Explanation:**\nUnder the given constraints, the string can be split into two parts: \n- The first part comprises of the first 10 characters, and has a length 15.\n- The next part comprises of the last 3 characters, and has a length 8.\n\n**Constraints:**\n\n*   `1 <= message.length <= 104`\n*   `message` consists only of lowercase English letters and `' '`.\n*   `1 <= limit <= 104`", "code": "\n    ```python\ndef split_message(message: str, limit: int) -> list[str]:\n    n = len(message)\n    a = (limit - 3) * (n // (limit - 3)) - n\n    b = n // (limit - 3)\n    if (n + b + a) % (limit - 2) != 0:\n        return []\n    num_parts = (n + b + a) // (limit - 2)\n    result = []\n    i = k = cnt = 0\n    while i < n or k < num_parts:\n        temp = []\n        while cnt < limit - 3:\n            cnt += 1\n            temp.append(message[i])\n            i += 1\n            if i == n: break\n        cnt = 0\n        temp.append(str(k+1) + \"/\" + str(num_parts) + \" \")\n        k += 1\n        result.append(\"\".join(temp))\n    return result\n```\n    \n    The algorithm first calculates the number of parts (`num_parts`) that the message would be divided into. It does so by calculating:\n* `a`: The number of extra characters needed for each part to be of length `limit` (except the last one).\n* `b`: The estimated number of parts calculated as the length of the message divided by `limit - 3`. The `-3` is because of the `<a/b> ` suffix.\n* If `(n + a + b) % (limit - 2) != 0`, it means it is not possible to split the message according to the given condition, so it returns an empty array.\n* Now, it calculates the actual `num_parts` by dividing `(n + a + b)` by `(limit - 2)`.\n\nThen it iterates through the message while keeping track of the current index `i`, current part index `k`, and a counter `cnt`. In each iteration, it creates a temporary string `temp` and fills it with at most `limit - 3` characters from the message. Then it appends the suffix with the current part index and the total number of parts. Finally, it adds the constructed part to the result array.\n\nThis algorithm ensures the message is divided into a minimum number of parts while keeping the length of the parts equal to `limit` except for the last one, which can be at most `limit`.\n    ", "signature": "def split_message(message: str, limit: int) -> list[str]:", "solution": "n = len(message)\n    a = (limit - 3) * (n // (limit - 3)) - n\n    b = n // (limit - 3)\n    if (n + b + a) % (limit - 2) != 0:\n        return []\n    num_parts = (n + b + a) // (limit - 2)\n    result = []\n    i = k = cnt = 0\n    while i < n or k < num_parts:\n        temp = []\n        while cnt < limit - 3:\n            cnt += 1\n            temp.append(message[i])\n            i += 1\n            if i == n: break\n        cnt = 0\n        temp.append(str(k+1) + \"/\" + str(num_parts) + \" \")\n        k += 1\n        result.append(\"\".join(temp))\n    return result", "prompt": "def split_message(message: str, limit: int) -> list[str]:\n\"\"\"\nYou are given a string, `message`, and a positive integer, `limit`.\n\nYou must **split** `message` into one or more **parts** based on `limit`. Each resulting part should have the suffix `\" \"`, where `\"b \"` is to be **replaced** with the total number of parts and `\"a \"` is to be **replaced** with the index of the part, starting from `1` and going up to `b`. Additionally, the length of each resulting part (including its suffix) should be **equal** to `limit`, except for the last part whose length can be **at most** `limit`.\n\nThe resulting parts should be formed such that when their suffixes are removed and they are all concatenated **in order**, they should be equal to `message`. Also, the result should contain as few parts as possible.\n\nReturn _the parts_ `message` _would be split into as an array of strings_. If it is impossible to split `message` as required, return _an empty array_.\n\n>>> split_message(\"this is really a very awesome message \", 9)\n[\"thi<1/14> \", \"s i<2/14> \", \"s r<3/14> \", \"eal<4/14> \", \"ly <5/14> \", \"a v<6/14> \", \"ery<7/14> \", \" aw<8/14> \", \"eso<9/14> \", \"me<10/14> \", \" m<11/14> \", \"es<12/14> \", \"sa<13/14> \", \"ge<14/14> \"]\n>>> split_message(\"short message \", 15)\n[\"short mess<1/2> \", \"age<2/2> \"]\n>>> split_message(\"hello world\", 5)\n[]\n\"\"\""}
{"id": 1987, "title": "Number of Unique Good Subsequences", "difficulty": "Hard", "content": "You are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0 \"`).\n\nFind the number of **unique good subsequences** of `binary`.\n\n*   For example, if `binary = \"001 \"`, then all the **good** subsequences are `[ \"0 \", \"0 \", \"1 \"]`, so the **unique** good subsequences are `\"0 \"` and `\"1 \"`. Note that subsequences `\"00 \"`, `\"01 \"`, and `\"001 \"` are not good because they have leading zeros.\n\nReturn _the number of **unique good subsequences** of_ `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n\n**Input:** binary =  \"001 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"0 \",  \"0 \",  \"1 \"\\].\nThe unique good subsequences are  \"0 \" and  \"1 \".\n\n**Example 2:**\n\n**Input:** binary =  \"11 \"\n**Output:** 2\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"1 \",  \"11 \"\\].\nThe unique good subsequences are  \"1 \" and  \"11 \".\n\n**Example 3:**\n\n**Input:** binary =  \"101 \"\n**Output:** 5\n**Explanation:** The good subsequences of binary are \\[ \"1 \",  \"0 \",  \"1 \",  \"10 \",  \"11 \",  \"101 \"\\]. \nThe unique good subsequences are  \"0 \",  \"1 \",  \"10 \",  \"11 \", and  \"101 \".\n\n**Constraints:**\n\n*   `1 <= binary.length <= 105`\n*   `binary` consists of only `'0'`s and `'1'`s.", "code": "\n    ```python\ndef count_good_substrings(s: str) -> int:\n    count = 0\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            count += 1\n    return count\n```\n    \n    The algorithm iterates through the given string `s` till the third last character. For each character, it checks if the current character and the next two characters are distinct. If they are distinct, it means we have found a good substring of length three and increase the `count`. After the iteration, the function returns the total count of good substrings found.\n    ", "signature": "def count_good_substrings(s: str) -> int:", "solution": "count = 0\n    for i in range(len(s) - 2):\n        if s[i] != s[i + 1] and s[i] != s[i + 2] and s[i + 1] != s[i + 2]:\n            count += 1\n    return count", "prompt": "def count_good_substrings(s: str) -> int:\n\"\"\"\nYou are given a binary string `binary`. A **subsequence** of `binary` is considered **good** if it is **not empty** and has **no leading zeros** (with the exception of `\"0 \"`).\n\nFind the number of **unique good subsequences** of `binary`.\n\n*   For example, if `binary = \"001 \"`, then all the **good** subsequences are `[ \"0 \", \"0 \", \"1 \"]`, so the **unique** good subsequences are `\"0 \"` and `\"1 \"`. Note that subsequences `\"00 \"`, `\"01 \"`, and `\"001 \"` are not good because they have leading zeros.\n\nReturn _the number of **unique good subsequences** of_ `binary`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\n>>> count_good_substrings(\"001\") 2\n>>> count_good_substrings(\"11\") 2\n>>> count_good_substrings(\"101\") 5\n\"\"\""}
{"id": 1526, "title": "Minimum Number of Increments on Subarrays to Form a Target Array", "difficulty": "Hard", "content": "You are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment each value by one.\n\nReturn _the minimum number of operations to form a_ `target` _array from_ `initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n**Example 1:**\n\n**Input:** target = \\[1,2,3,2,1\\]\n**Output:** 3\n**Explanation:** We need at least 3 operations to form the target array from the initial array.\n\\[**0,0,0,0,0**\\] increment 1 from index 0 to 4 (inclusive).\n\\[1,**1,1,1**,1\\] increment 1 from index 1 to 3 (inclusive).\n\\[1,2,**2**,2,1\\] increment 1 at index 2.\n\\[1,2,3,2,1\\] target array is formed.\n\n**Example 2:**\n\n**Input:** target = \\[3,1,1,2\\]\n**Output:** 4\n**Explanation:** \\[**0,0,0,0**\\] -> \\[1,1,1,**1**\\] -> \\[**1**,1,1,2\\] -> \\[**2**,1,1,2\\] -> \\[3,1,1,2\\]\n\n**Example 3:**\n\n**Input:** target = \\[3,1,5,4,2\\]\n**Output:** 7\n**Explanation:** \\[**0,0,0,0,0**\\] -> \\[**1**,1,1,1,1\\] -> \\[**2**,1,1,1,1\\] -> \\[3,1,**1,1,1**\\] -> \\[3,1,**2,2**,2\\] -> \\[3,1,**3,3**,2\\] -> \\[3,1,**4**,4,2\\] -> \\[3,1,5,4,2\\].\n\n**Constraints:**\n\n*   `1 <= target.length <= 105`\n*   `1 <= target[i] <= 105`", "code": "\n    ```python\ndef entityParser(text: str) -> str:\n    entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)\n```\n\n    \n    1. Initialize a dictionary or hashmap named `entities` with keys as the HTML entity representation and values as the corresponding plaintext characters.\n2. Initialize an empty string or character list named `result` to store the parsed text.\n3. Loop through each character of the input `text`.\n4. If the character is '&', try to match it as an entity in the dictionary.\n5. If a match is found within the next 7 characters, append the decoded entity character to the `result` and update the loop counter `i` to skip the matched entity.\n6. If no match is found, append the character to `result` as is.\n7. After the loop, return the `result` as the parsed text.\n    ", "signature": "def entityParser(text: str) -> str:", "solution": "entities = {\n        \"&quot;\": '\\\"',\n        \"&apos;\": '\\'',\n        \"&amp;\": '&',\n        \"&gt;\": '>',\n        \"&lt;\": '<',\n        \"&frasl;\": '/'\n    }\n\n    result, i = [], 0\n    while i < len(text):\n        if text[i] == '&':\n            temp = ''\n            for j in range(i, min(i+7, len(text))):\n                temp += text[j]\n                if temp in entities:\n                    result.append(entities[temp])\n                    i = j\n                    break\n            else:\n                result.append(text[i])\n        else:\n            result.append(text[i])\n        i += 1\n    return ''.join(result)", "prompt": "def entityParser(text: str) -> str:\n\"\"\"\nYou are given an integer array `target`. You have an integer array `initial` of the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment each value by one.\n\nReturn _the minimum number of operations to form a_ `target` _array from_ `initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n>>> entityParser([1,2,3,2,1]) 3\n>>> entityParser([3,1,1,2]) 4\n>>> entityParser([3,1,5,4,2]) 7\n\"\"\""}
{"id": 828, "title": "Count Unique Characters of All Substrings of a Given String", "difficulty": "Hard", "content": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\n*   For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.\n\n**Example 1:**\n\n**Input:** s =  \"ABC \"\n**Output:** 10\n**Explanation:** All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\n**Example 2:**\n\n**Input:** s =  \"ABA \"\n**Output:** 8\n**Explanation:** The same as example 1, except `countUniqueChars`( \"ABA \") = 1.\n\n**Example 3:**\n\n**Input:** s =  \"LEETCODE \"\n**Output:** 92\n\n**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of uppercase English letters only.", "code": "\n    ```python\ndef xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ", "signature": "def xor_game(nums: List[int]) -> bool:", "solution": "xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0", "prompt": "def xor_game(nums: List[int]) -> bool:\n\"\"\"\nLet's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\nFor example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.\n\n>>> xor_game(\"ABC\") 10\n>>> xor_game(\"ABA\") 8\n>>> xor_game(\"LEETCODE\") 92\n\"\"\""}
{"id": 1617, "title": "Count Subtrees With Max Distance Between Cities", "difficulty": "Hard", "content": "There are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Output:** \\[3,4,0\\]\n**Explanation:**\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\nNo subtree has two nodes where the max distance between them is 3.\n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\]\n**Output:** \\[1\\]\n\n**Example 3:**\n\n**Input:** n = 3, edges = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** \\[2,1\\]\n\n**Constraints:**\n\n*   `2 <= n <= 15`\n*   `edges.length == n-1`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   All pairs `(ui, vi)` are distinct.", "code": "\n    ```python\ndef winnerSquareGame(n: int) -> bool:\n    dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]\n```\n    \n    We use dynamic programming to solve this problem. We create a boolean array `dp` of size `(n + 1)` to store if the current player can win with the remaining stones at position `i`. Each entry `dp[i]` is set to `false` initially.\n\nWe iterate through all possible numbers of stones from `1` to `n`. For each stone `i`, we iterate through all possible square numbers `j` less than or equal to `i`. Inside the inner loop, we check if the current player, when playing optimally, can win using the stones `i - j*j`. If the current player cannot win (`dp[i - j * j]` is false), it means the current player can win using the square number `j` and we set `dp[i]` to `true`.\n\nThe result for Alice winning the game is the value of `dp[n]`.\n    ", "signature": "def winnerSquareGame(n: int) -> bool:", "solution": "dp = [False] * (n + 1)\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            if not dp[i - j * j]:\n                dp[i] = True\n                break\n            j += 1\n    return dp[n]", "prompt": "def winnerSquareGame(n: int) -> bool:\n\"\"\"\nThere are `n` cities numbered from `1` to `n`. You are given an array `edges` of size `n-1`, where `edges[i] = [ui, vi]` represents a bidirectional edge between cities `ui` and `vi`. There exists a unique path between each pair of cities. In other words, the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1`, find the number of subtrees in which the **maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_ `dth` _element **(1-indexed)** is the number of subtrees in which the **maximum distance** between any two cities is equal to_ `d`.\n\n**Notice** that the **distance** between the two cities is the number of edges in the path between them.\n\n>>> winnerSquareGame(4, [[1,2],[2,3],[2,4]]) [3,4,0]\n>>> winnerSquareGame(2, [[1,2]]) [1]\n>>> winnerSquareGame(3, [[1,2],[2,3]]) [2,1]\n\"\"\""}
